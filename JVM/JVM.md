## 对象分配原则    

1. 对象优先在Eden分配
2. 空间分配担保（新生代复制到老年代时）
3. 大对象直接进入老年代（部分JVM才有）
4. 长期存活对象进入老年代
5. 动态对象年龄判定（如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。）

## 虚拟机优化技术

1. 逃逸分析
2. 本地线程分配缓冲 TLAB

## 垃圾回收算法

1. 复制回收算法升级版（Appel）（新生代）8 ：1：1

   实现简单、运行高效、没有内存碎片，空间利用率低    升级版：提高空间利用率和空间分配担保   

2. 标记清除算法

   优点：可以做到线程不暂停     缺点：位置不连续、会产生碎片空间      

3. 标记整理算法 --- 先整理  在回收

   优点：没有内存碎片   缺点：指针需要移动

<img src="image-20230211170439981.png" alt="image-20230211170439981" style="zoom:50%;" />



## CMS垃圾回收器 

特性：并发 、只针对老年代

以减少STW为目的的垃圾回收器  Concurrent Mark Sweep    使用了垃圾清除算法

![image-20230211185109763](image-20230211185109763.png)

```
老年代的机制与一个叫CARD TABLE的东西（这个东西其实就是个数组,数组中每个位置存的是一个byte）密不可分。

CMS将老年代的空间分成大小为512bytes的块，card table中的每个元素对应着一个块。

并发标记时，如果某个对象的引用发生了变化，就标记该对象所在的块为  dirty card。

并发预清理阶段就会重新扫描该块，将该对象引用的对象标识为可达。
```

### 预清理：只一次

- 并发标记过程中，eden区对象引用了old对象（**发生跨代引用**），则认为eden区对象为可达
- 老年代内部引用变化，将该分区标记为dirty，为重新标记提供方向。记录类似于卡表结构

### 并发可中断预清理：循环

- 同上，但eden区变成了*survive*区
- 它会尝试若干次预清理过程，直到次数到达GC允许的上限，或者超过指定时间
-   -可中断的条件：1）可以设置循环次数。2）可以设置时间。3）EDEN区的最大比例（大于比例退出循环）。

### CMS垃圾清理日志

![image-20230211190021502](image-20230211190021502.png)

### CMS存在的问题

- CPU敏感  要求CPU >= 4
- 浮动垃圾   并发清理过程中产生的垃圾，要预留空间，导致无法等到内存占用满再开始GC
- 内存碎片   搭配其他垃圾回收器使用

## JVM调优

![image-20230211194627786](image-20230211194627786.png)

![image-20230211195807842](image-20230211195807842.png)

## 常量池

- #### Class常量池

  主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：

  ·被模块导出或者开放的包（Package）

  ·类和接口的全限定名（Fully Qualified Name）

  ·字段的名称和描述符（Descriptor）

  ·方法的名称和描述符

  ·方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）

  ·动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

- #### 运行时常量池

  将运行时的字面量转换成真实地址

  运行时常量池相对于class温江常量池的一个重要特征是具有**动态性**。这是什么意思呢，就是当你的class文件一旦编译后，你的class常量池就是确定了的，而运行时常量池在运行期间也可能有新的常量放入池中（如String类的intern()方法）

- #### 字符串常量池

