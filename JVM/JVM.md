## 对象分配原则    

1. 对象优先在Eden分配
2. 空间分配担保（新生代复制到老年代时）
3. 大对象直接进入老年代（部分JVM才有）
4. 长期存活对象进入老年代
5. 动态对象年龄判定（如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。）

## 虚拟机优化技术

1. 逃逸分析
2. 本地线程分配缓冲 TLAB

## 垃圾回收算法

1. 复制回收算法升级版（Appel）（新生代）8 ：1：1

   实现简单、运行高效、没有内存碎片，空间利用率低    升级版：提高空间利用率和空间分配担保   

2. 标记清除算法

   优点：可以做到线程不暂停     缺点：位置不连续、会产生碎片空间      

3. 标记整理算法 --- 先整理  在回收

   优点：没有内存碎片   缺点：指针需要移动

<img src="F:\AndroidStudy\笔记\Blog\JVM\image-20230211170439981.png" alt="image-20230211170439981" style="zoom:50%;" />



## CMS垃圾回收器 

特性：并发 、只针对老年代

以减少STW为目的的垃圾回收器  Concurrent Mark Sweep    使用了垃圾清除算法

![image-20230211185109763](F:\AndroidStudy\NoteImage\image-20230211185109763-16761137026481.png)

```
老年代的机制与一个叫CARD TABLE的东西（这个东西其实就是个数组,数组中每个位置存的是一个byte）密不可分。

CMS将老年代的空间分成大小为512bytes的块，card table中的每个元素对应着一个块。

并发标记时，如果某个对象的引用发生了变化，就标记该对象所在的块为  dirty card。

并发预清理阶段就会重新扫描该块，将该对象引用的对象标识为可达。
```

### 预清理：只一次

- 并发标记过程中，eden区对象引用了old对象（**发生跨代引用**），则认为eden区对象为可达
- 老年代内部引用变化，将该分区标记为dirty，为重新标记提供方向。记录类似于卡表结构

### 并发可中断预清理：循环

- 同上，但eden区变成了*survive*区
- 它会尝试若干次预清理过程，直到次数到达GC允许的上限，或者超过指定时间
-   -可中断的条件：1）可以设置循环次数。2）可以设置时间。3）EDEN区的最大比例（大于比例退出循环）。

### CMS垃圾清理日志

![image-20230211190021502](F:\AndroidStudy\NoteImage\image-20230211190021502-16761137095503.png)

### CMS存在的问题

- CPU敏感  要求CPU >= 4
- 浮动垃圾   并发清理过程中产生的垃圾，要预留空间，导致无法等到内存占用满再开始GC
- 内存碎片